(in-package :otl)

(defparameter *otl-cli-options*
  '("gloss" "glossfile=" "help" "ignore-errors" "no-overwrite" "outfile=" "output-spec=" "query=" "papersize=" "sexp" "stitch" "style=" "subtype=" "version"))

(defparameter *otl-cli-short-help-string*
  "USAGE: 

otl --query <query text>
otl [options] file1 ... fileN

otl is a text processing utility. Each file specified by file1 through fileN is parsed and a corresponding output file generated.

Examples:
   otl foo.txt
   otl --style \"polished\" goo.txt

")

(defparameter *otl-cli-help-string*
  "USAGE: 

otl --query <query text>
otl [options] file1 ... fileN


For the first form of the command, <query text> may be one of

input
        output a list of valid 'input-spec' values
output
        output a list of valid 'output-spec' values
styles
        output a list of available styles, each as a style name on a separate line


For the second form of the command, file1 through fileN are processed as input files. [options] may include any of

--gloss
        include glossary
--glossfile gfile
        write glossary data to gfile and include glossary term markup
--help
        output this message
--no-overwrite
        don't overwrite preexisting output file
--outfile FILE
        specify output filename (note that behavior is guaranteed only in the case where a single file is parsed); if --stitch is true, this option is ignored; if --stitch isn't true and if --outfile isn't specified, then the output file(s), by default, are written to the same directory as the input files and have the same file names as the input files, but with the suffix corresponding to the output-spec provided
--output-spec output-spec
        specify a 'output-spec' value (':text', ':latex', ':html' (the default), or a path corresponding to a parameter file)
--papersize PAPER-SIZE
        PAPER-SIZE is a CLPS paper size nickname sans colon ('A4' or 'letter')
--sexp
        print the sexp which would be otherwise executed and then halt
--stitch
        process, as the equivalent of a single file, the concatenatation of file1 through fileN
--style stylename
        request that style specified by stylename be used

Report bugs at https://github.com/thomp/otl/issues.

otl is a text processing utility. Each file specified by file1 through fileN is parsed and a corresponding output file generated.

Examples:
   otl foo.txt
   otl --style \"polished\" goo.txt

")

;; application generated by buildapp calls this with *POSIX-ARGV* as sole argument
;; d630:otl# ./otl2 foo --path is --goo moo
;; gives posix-argv as ("./otl2" "foo" "--path" "is" "--goo" "moo")
(defun invoking-otl-from-shell (&rest posix-argv)
  "This is intended to be called as an executable. It will set an error code and exit the current (lisp) process with that status."
  (declare (ignore posix-argv))
  ;(format t "invoking-otl-from-shell~%")
  ;; ensure shell command always completes and returns a meaningful exit code
  (multiple-value-bind (successp condition)
      (ignore-errors
	;; parse command-line as described by *otl-cli-help-string*
	(multiple-value-bind (args valid-options free-args)
	    (unix-options:getopt
	     (unix-options:cli-options)
	     nil
	     *otl-cli-options*) 
	  (otl-internal args valid-options free-args)
	  ;; assume 'success' if we've made it to here
	  t))
    (cond (successp
	   (sb-ext:exit :code 0))
	  (t
	   (log-error condition)
	   ;; timeout after 10 seconds if any threads fail to join
	   (sb-ext:exit :code 1 :abort nil :timeout 10)))))

(defun log-error (condition)
  (ensure-directories-exist (otlb::otl-dir))
  (let ((log-file (merge-pathnames
		   (make-pathname :name "log")
		   (otlb::otl-dir)))
	(error-msg
	 (with-output-to-string (s)
	   (format s " ERROR~% ")
	   (print-object condition s))))
    (write-string error-msg t)
    (write-char #\Newline t)
    (with-open-file (s log-file
		       :direction :output
		       :if-does-not-exist :create
		       :if-exists :append)
      (format s "~S~%" (get-universal-time))
      (write-string error-msg s)
      (write-char #\Newline s))))

(defun otl-internal (args valid-options free-args)
  "VALID-OPTIONS is a list of strings."
  ;(format t "valid-options: ~S~%" valid-options)
  (if (not (or args free-args valid-options))
      (push "help" valid-options))
  (let ((f nil)
	(args nil)
	(sexpp (cond ((member "sexp" valid-options :test #'equalp)
		      (setf valid-options (remove "sexp" valid-options :test #'equalp))
		      t)
		     (t
		      nil))))
    (cond ((and (equal (car valid-options) "query")
		(equal (length valid-options) 2)
		(not free-args))
	   (setf f 'otl-internal-query)
	   (setf args (list (second valid-options))))
	  (t
	   ;(format t "HERE!!!~%")
	   (setf f 'otl-internal-parse-render)
	   (setf args (list valid-options free-args))))
    (cond (sexpp
	   (format t "(apply '~S '~S)~%" f args))
	  (t
	   (apply f args)))))

(defun otl-internal-query (query-text)
  (cond ((equal query-text "input")
	 (map nil #'(lambda (x) (format t "~S~%" x))
	      (otlp::input-specs)))
	((equal query-text  "styles")
	 (map nil #'(lambda (pathname)
		      (format t "~A~%" (pathname-name pathname)))
	      (otlr::default-stylepaths)))
	((equal query-text  "output")
	 (map nil #'(lambda (x) (format t "~S~%" x))
	      (otlr::output-specs)))
	(t
	 (format t "Invalid query text.~%"))))

(defun otl-internal-parse-render (valid-options free-args)
  (let ((glossp nil)		  ; default is to not include glossary
	(glossfile nil)
	(ignore-errors-p nil)
	(outfile nil)
	(overwrite-p t)
	(output-spec nil)
	(output-subtype nil)
	(papersize otlb::*paper-size-nickname-default*)
	(stitch nil)
	(style nil))
    ;; loop to remove any ambiguity with respect to nature of valid-options parameters
    (do ((vo (pop valid-options) (pop valid-options)))
	((not vo))
      (cond ;;((equalp vo "version") (format t "~S~%" *VERSION*))
	((equalp vo "help") (write-string *otl-cli-short-help-string* t))
	((equalp vo "ignore-errors") (setf ignore-errors-p t))
	((equalp vo "gloss") (setf glossp t))
	((equalp vo "glossfile")
	 (let ((glossfile? (pop valid-options)))
	   (if glossfile?
	       (setf glossfile glossfile?))))
	((equalp vo "no-overwrite") (setf overwrite-p nil))
	((equalp vo "stitch") (setf stitch t))
	((equalp vo "style")
	 (let ((stylename? (pop valid-options)))
	   (if stylename?
	       (setf style stylename?)
	       (format t "Must specify a style.~%"))))
	((equalp vo "outfile")
	 (let ((outfile? (pop valid-options)))
	   (setf outfile outfile?)))
	((equalp vo "output-spec")
	 (let ((output-spec? (pop valid-options)))
	   (setf output-spec (otlb::string-to-output-spec output-spec?))))
	((equalp vo "papersize")
	 (let ((papersize? (pop valid-options)))
	   (setf papersize (or (otlb::string-to-paper-size-nickname papersize?)
			       otlb::*paper-size-nickname-default*))))
	((equalp vo "subtype")
	 (let ((output-subtype? (pop valid-options)))
	   (setf output-subtype (otlb::string-to-output-spec output-subtype?))))))
    ;; set output-spec default if output-spec not specified
    (unless output-spec (setf output-spec :html))
    (if free-args
	;; grab filename(s) from shell command line
	(let* ((filenames free-args)
	       ;; %WD%: a path object -- the directory the command was invoked in
	       (%wd% (dfile:wd))
	       ;; ensure all filenames are complete and not relative...
	       (unambiguous-filenames (apply #'dfile:add-dir-if-absent %wd% filenames))
	       ;; temporary file (only used for stitched output)
	       (tmpfile (if stitch
			    (dfile:make-unique-path (dfile:tempdir)
						    :createp nil))))
	  ;; lazy kludge implementing stitch
	  (let ((final-filenames
		 (cond (stitch
			(dfile::files-to-file tmpfile unambiguous-filenames)
			(list tmpfile))
		       (t unambiguous-filenames))))
	    ;; run parse-and-render-file on each filename
	    ;; OUTFILES: collect pathnames corresponding to output files
	    (let ((outfiles
		   (mapcar #'(lambda (uf)
			       (parse-and-render-file uf output-spec
						      :glossfile glossfile
						      :glossp glossp
						      :ignore-errors-p ignore-errors-p
						      :outfile outfile
						      :output-subtype output-subtype
						      :overwrite-p overwrite-p
						      :paper-size-nickname papersize
						      :style style))
			   final-filenames)))
	      ;; cleanup
	      (when stitch
		;; move output file to current directory from its present location
		(let ((outfile (first outfiles)))
		 (dfile::mv outfile
			    (merge-pathnames
			     (make-pathname
			      :name (pathname-name outfile)
			      :type (pathname-type outfile))
			     %wd%)))
		;; delete temporary 'stitched' input file
		(delete-file tmpfile))))
	  ;; return an appropriate exit code from the perspective of the shell
	  )
	(format t "An input file was not specified. Try 'otl --help'.~%~%"))))

;; PAPER-SIZE-NICKNAME should be a CLPS nickname

;; FIXME: fix docstring below to describe what should happen when OUTPUT-SPEC is NIL
(defun parse-and-render-file (infile output-spec &key (author "") (date-created 0) (date-last-modified 0) glossfile glossp ignore-errors-p (input-spec :otl) outfile output-subtype overwrite-p (paper-size-nickname otlb::*paper-size-nickname-default*) style (title ""))
  "Parse INFILE, a string or a path object specifying a full path (directory and file name). Generate a file, OUTFILE, based on the transformation defined by OUTPUT-SPEC (a keyword, path, or pathspec) and OUTPUT-SUBTYPE. If OUTFILE is NIL...

Return the path object corresponding to the file generated.

If GLOSSP is true, include a glossary. GLOSSFILE can be used to specify a file to send glossary data to. If GLOSSFILE is true, *GLOSS-FILESPEC* is set to GLOSSFILE. *GLOSS-FILESPEC* points to an accessory file which is used to store glossary data; some output languages (e.g., LaTeX) may utilize such a file to generate a glossary.

OUTPUT-SUBTYPE may be used to specify a specific variant of a given output format (e.g., OUTPUT-SPEC might be :LATEX and OUTPUT-SUBTYPE might be :SECTION or :DOCUMENT).

IGNORE-ERRORS-P is either T or NIL.

STYLE is made available to internal functions as the special variable OTLR::%STYLE%. STYLE-STRING accepts %STYLE% as an argument representing a pathname name. STYLE-STRING returns a string corresponding to the content of the file in directory *STYLES-DIRPATH* with the name STYLE and with suffix *STYLES-SUFFIX*. Presumably the string can be embedded in the rendered document at an appropriate point (see DOCTOP-HTML for an example). If a STYLE is not specified, use the default style specified by *DEFAULT-STYLE-NAME*."
  (declare (boolean ignore-errors-p)
	   (keyword paper-size-nickname))
  (let ((style (or style otlr::*default-style*))
	(%indexterms% nil)
	(out-dir (pathname-directory infile)))
    (declare (special %indexterms%))
    ;; FIXME: PARSE-RESET should set %indexterms%, checking for indexterms file in out-dir
    (otlp::parse-reset
     input-spec
     (otlb::read-indexterms out-dir))
    (let ((parse-tree
	   (otlp:parse-file infile
			    :author author
			    :date-created date-created
			    :date-last-modified date-last-modified
			    :paper-size-nickname paper-size-nickname
			    :title title)))
      (let ((outstring (otlr::document-to-string parse-tree output-spec :glossfile glossfile :glossp glossp :ignore-errors-p ignore-errors-p :out-dir out-dir :output-subtype output-subtype :style style))
	    (outfile (or outfile
			 (let ((suffix (or (first (otlr::get-*render2*-value :suffix)) "otlout"))
			       (directory out-dir)
			       (name (pathname-name infile)))
			   (make-pathname :name name :directory directory :type suffix)))))
	(if (and (dfile:file-or-directory-exists outfile) (not overwrite-p))
	    (cerror "Overwrite ~S ?" (format nil "File ~S exists" outfile) outfile))
	(dfile:string-to-file
	 (if otlr::*toc-index*
	     (otlr::insert-toc outstring otlr::*toc-index*)
	     outstring)
	 outfile)
	outfile))))

(defun parse-and-render-in-dir (dir &key (input-spec :otl) output-spec output-subtype overwrite-p style (type "txt"))
  "TYPE, a string, describes the filetype (suffix 'foo' for file goo.foo) associated with the [input] files to be parsed."
  (let ((paths (dfile:filepaths-in-dirpath dir :type type)))
    (map nil
	 #'(lambda (filepath)
	     (parse-and-render-file filepath output-spec :input-spec input-spec :output-subtype output-subtype :overwrite-p overwrite-p :style style))
	 paths)))

(defun parse-and-render-in-subdirs-of-dir (dir &key (input-spec :otl) output-spec output-subtype overwrite-p style (type "txt"))
  "TYPE, a string, describes the filetype (suffix 'foo' for file goo.foo) associated with the [input] files to be parsed."
  (let ((paths (dfile:dirpaths-in-dir dir)))
    (map nil
	 #'(lambda (dirpath)
	     (parse-and-render-in-dir dirpath :input-spec input-spec :output-spec output-spec :output-subtype output-subtype :overwrite-p overwrite-p :style style :type type)
	     )
	 paths)))

(defparameter *version* "git")
