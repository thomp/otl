(in-package :otlp)
;;
;; lexer-post.lisp: process object generated by lexer before parsing
;;
(defun post-process-lex-vector (lex-vector) 
  (strip-linesgroup-beginswith
   (strip-comments 
    ;; facilitate list processing
    (strip-lexer-list-items lex-vector))))

(defun strip-comments (lex-vector)
  (let ((lv-length (length lex-vector)))
    (let ((new-vector (make-array 4 :fill-pointer 0)))
      (dotimes (x lv-length)
	(let ((lline (elt lex-vector x))) 
	  (if (not (eq :comment (first lline)))
	      (vector-push-extend lline new-vector))))
      new-vector)))

(defun strip-lexer-list-items (lex-vector)
  (let ((imax (1- (length lex-vector))))
   (loop 
      for i from 0 to imax
      for lline across lex-vector
      ;;do (format t "STRIP-LEXER-LIST-ITEMS.xx: i: ~S~%lline: ~S~%" i lline)
      ;; for a potential list item (LIST?), check if it is truly a list item
      ;; handle end cases (i=0 and i=(1- (length lex-vector))
      if (eq (lline-type lline) :list?) collect (strip-lexer-list-items-helper lline (if (> i 0) (elt lex-vector (1- i))) (if (< i imax) (elt lex-vector (1+ i))) )
      else collect lline
	)))

;; figure out if a potential list item (LIST?) should be a 'regular line' or a LIST item
;; LLINE-1 and LLINE+1 are the llines before and after the line subjected to consideration
(defun strip-lexer-list-items-helper (lline lline-1 lline+1)
  ;; simple approach: process all potential list items
  ;; if it's a list item then we do this...
  (multiple-value-bind (front rest preceding)
      (strip-list-item-designator 
       (lline-text lline)
       (second (first lline))) 
    ;; retain stripped (FRONT) information -- it's needed if line isn't used as a list item
    
    ;; FIXME: we change :LIST? to :LIST but this change is meaningless -- this is still only tentatively a list item --> :LIST? would be more appropriate
    ;; note: don't do this: (setf (first (first lline)) :LIST) -> this item may be shared by subsequent list items
    (list (cons :list
		(append
		 (rest (first lline)) 
		 (list :CUT front) 
		 (list :REST rest)
		 ;; the only thing preceding the regex match should be tabs (see LIST-SYMBOL-REGEX->LEX-REGEX)
		 (list :TABS (count #\Tab preceding))))
	  (second lline)		; rest
	  ))
  )

(defun strip-lexer-list-items-helper-OLD (lline lline-1 lline+1)
  (if (or (same-type-and-tablevel lline-1 lline)
	  (same-type-and-tablevel lline+1 lline))
      (progn
       ;; if it's a list item then we do this...
       (multiple-value-bind (front rest preceding)
	   (strip-list-item-designator 
	    (lline-text lline)
	    (second (first lline))) 
	 ;; retain stripped (FRONT) information -- it's needed if line isn't used as a list item
	 
	 ;; change :LIST? to :LIST for a confirmed list item
	 ;; don't do this: (setf (first (first lline)) :LIST) -> this item may be shared by subsequent list items
	 (list (cons :list
		     (append
		      (rest (first lline)) 
		      (list :CUT front) 
		      (list :REST rest)
		      ;; the only thing preceding the regex match should be tabs (see LIST-SYMBOL-REGEX->LEX-REGEX)
		      (list :TABS (count #\Tab preceding))))
	       (second lline)		; rest
	       )))
      (progn
	(list (cons :nonemptyline (rest (first lline)))
	      (second lline)))))

(defun same-type-and-tablevel (lline1 lline2)
  (and (equalp (lline-type lline1)
	       (lline-type lline2))
       (= (lline-tablevel lline1)
	  (lline-tablevel lline2))))

;; list objects: list items are defined by regex in parameter file; this is easiest place to strip that from text of list object
(defun strip-lexer-list-itemsOLD (lex-vector)
  (map 'vector
       #'(lambda (lline)
	   (format t "lline: ~S~%" lline)
	   (cond ((eq (lline-type lline) :list) 
		  ;; capture list item designator and remainder of line as distinct entities
		  ;; FRONT = material stripped from front
		  ;; REST = rest of line
		  (multiple-value-bind (front rest preceding)
		      (strip-list-item-designator 
		       (lline-text lline)
		       (second (first lline))) 
		    ;; retain stripped (FRONT) information -- it's needed if line isn't used as a list item
		    (list (append (first lline) 
				  (list :CUT front) 
				  (list :REST rest)
				  ;; the only thing preceding the regex match should be tabs (see LIST-SYMBOL-REGEX->LEX-REGEX)
				  (list :TABS (count #\Tab preceding)))
			  (second lline) ; rest
			  )))
		 (t lline)))
       lex-vector))

(defun strip-linesgroup-beginswith (lex-vector)
  ;; look for llines with one of the keys specified for :beginswith items

  (let ((beginswith-map (*parse*-linesgroup-alist :parsertype :beginswith)))
    (map 'vector
	 #'(lambda (lline)
	     (let ((strip-regex? (otlb::aval (lline-type lline) 
					     beginswith-map)))
	      (cond (strip-regex?
		     ;; strip list item designator from text
		     (list (first lline)
			   (otlb::cut-regex-match-from-front
			    (lline-text lline)
			    strip-regex?)))
		    (t lline))))
	 lex-vector)))

(defun *parse*-linesgroup-parse-specs (&key parsertype)
  (loop for pair in (*parse*-linesgroup-pairs)
       when (eq (pair-parsertype pair) parsertype)
       collect (pair-parse-spec pair)))

;; return an alist with the first value of the internal-spec as the alist key and, as the alist value, the second element of the parse-spec 
;; -->> allows quick lookup from lline of string which should be stripped from start of line
(defun *parse*-linesgroup-alist (&key parsertype)
  (loop for pair in (*parse*-linesgroup-pairs)
     when (eq (pair-parsertype pair) parsertype)
     collect (cons (first (pair-internal-spec pair)) (second (pair-parse-spec pair)))))

(defun strip-linesgroup-beginswith-for-lline (&rest junk)
  (declare (ignore junk)))

(defun strip-list-item-designator (text regex)
  "Return three values:
- list designator (cut material)
- content of list item itself
- content preceding the list designator"
  ;; MATCH-INDICES define the location of the list item designator
  (let ((match-indices
	 (cl-ppcre:all-matches regex text)))
    (if match-indices 
	(values
	 (subseq text (first match-indices) (second match-indices))
	 (subseq text (second match-indices))
	 (subseq text 0 (first match-indices))))))
